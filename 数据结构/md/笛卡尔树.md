### 笛卡尔树 

Wiki百科的笛卡尔树描述：

> 无相同元素的数列构造出的笛卡尔树具有下列性质：
>
> 1. 结点一一对应于数列元素。即数列中的每个元素都对应于树中某个唯一结点，树结点也对应于数列中的某个唯一元素
> 2. 中序遍历（in-order traverse）笛卡尔树即可得到原数列。即任意树结点的左子树结点所对应的数列元素下标比该结点所对应元素的下标小，右子树结点所对应数列元素下标比该结点所对应元素下标大。
> 3. 树结构存在堆序性质，即任意树结点所对应数值大／小于其左、右子树内任意结点对应数值
>
> 根据堆序性质，笛卡尔树根结点为数列中的最大／小值，树本身也可以通过这一性质递归地定义：根结点为序列的最大／小值，左、右子树则对应于左右两个子序列，其结点同样为两个子序列的最大/小值。因此，上述三条性质唯一地定义了笛卡尔树。若数列中存在重复值，则可用其它排序原则为数列中相同元素排定序列，例如以下标较小的数为较小，便能为含重复值的数列构造笛卡尔树。

#### 笛卡尔树的相关应用：

笛卡尔树可以有效地处理范围最值查询，通过将定义在数列上的RMQ问题转化为定义在树结构上的最低公共祖先问题。数列以线性时间构造出笛卡尔树，笛卡尔树则能以常数时间处理最低公共祖先查询，因此在线性时间的预处理后，范围最值查询能以常数时间完成。

 **构造笛卡尔树的时间复杂度O(n)**

O(n)构造笛卡尔树的算法

```c++
const int MAXN = 1e5+5;
int l[MAXN],r[MAXN]; //使用两个数组记录树形结构，l[i]表示a[i]的左子节点的下标，r[i]同理
int a[MAXN];//记录数列元素
stack<int> s;
void create(int p){
	int rta = 0;
    for(int i = 1; i <= p; i++){
        l[i] = r[i] = 0;  // 初始化当前节点的左右子节点
        while(!s.empty() && a[i] < a[s.top()]){ //1.
            									//当新的节点的值小于栈顶节点的值，
            									//就将当前节点的左子节点设为栈顶节点
            l[i] = s.top();
            s.pop();
        }
        if(!s.empty())    //2. 只要栈里还有值，就把当前新节点作为栈顶节点的右子节点
        	r[s.top()] = i;
        s.push(i);
    }
    while(!s.empty()){
        rta = s.top();
        s.pop();
    }
}
```

**关于代码中的几点解释**

1处：

为什么要设为左子节点呢？

为了满足笛卡尔树的性质：`中序遍历笛卡尔树即可得到原数列` 。 由于我们从前往后依次扫描数组，栈中的元素在原数列中一定是在当前元素之前出现，按照中序遍历的性质：先后扫描左子树、根节点、右子树。所以将当前节点置为根节点，之前的节点设为根节点的左子节点。

2处：

为什么会有这一步？

容易直到，当程序运行到当前判断语句时，一定满足的是$a[i] \ge a[s.top()]$ 。然后依然要满足笛卡尔树中序遍历的性质，所以要将当前节点置为栈顶节点的右子节点。



当前代码构造的是类似于小顶堆的笛卡尔树（父节点小于子节点），我们可以通过略微的修改就能构造类似于大顶堆的笛卡尔树。

即将` a[i] < a[s.top()]` 改为` a[i] > a[s.top()]`





 ### 我仍然不曾知道的是

怎样在常数时间内求得LCA？

怎样通过笛卡尔树将RMQ问题转换为LCA问题？

